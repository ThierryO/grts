---
title: "Our implementation of GRTS"
author: "Thierry Onkelinx"
date: "26 maart 2018"
bibliography: grts.bib
output: rmarkdown::html_document
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteDepends{ggplot2}
  %\VignetteDepends{dplyr}
  %\VignetteDepends{tidyr}
  %\VignetteDepends{sp}
  %\VignetteDepends{rgeos}
  %\VignetteIndexEntry{Our implementation of GRTS}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
library(knitr)
opts_chunk$set(
  echo = TRUE,
  fig.width = 3,
  fig.height = 3
)
library(ggplot2)
library(dplyr)
library(tidyr)
set.seed(20180327)
```


We assume that the reader is already familiar with the principles of GRTS. Please read the introduction first when you are not familiar. Use the R command `vignette("intro", package = "GRTS")` to open the introduction.

## A recursive algorithm

The workhorse of this package is `nd_ranking()`. It is not indented to be called directly by the user, as it requires a correctly prepared input. One requirement is that the each dimension of the input has exactly $2^L$ identically spaced elements with $L$ the number of hierarchical levels. At level $l$, `nd_ranking()` splits the quadrant into 4 subquadrant and assigns a random number from 0 to 3 to each subquadrant. When $l = 1$, no further splitting is required and `nd_ranking()` returns the numbers for each subquadrant. Those numbers are the 1D addresses of of the subquadrants, conditional on the quadrant that they are part of. When $l > 1$, `nd_ranking()` will apply `nd_ranking()` to each subquadrant to get the conditional 1D addresses of level $l - 1$. These are combined with the random numbers of the current level $l$ to form the conditional 1D addresses of level $l$. Since level $L$ is the top level, its conditional 1D addresses are the final 1D addresses.

## Number of dimensions

The goal of GRTS is create spatially balanced samples. Hence with two dimensions in mind. However at each hierarchical level, each dimension is split separately into two equal sized segments and then the indices are recombined in the a 1D address. So we could apply exactly to same algorithm on a 1 dimensional object. This would be the equivalent of splitting a line segment recursively in half. This is illustrated in the image below. An expansion into 3D is similar. A cube is the 3D equivalent of the 2D quadrant. The cube is split in two halves along each of its dimensions resulting in 8 subcubes. We can generalise this into $n$ dimensions. We start with an $n$ dimensional hypercube which is split in half along each of the $n$ dimensions resulting in $2^n$ sub-hypercubes.

```{r echo = FALSE, fig.height = 1, fig.cap = "Hierarchical binary split of a 1 dimensional dataset"}
data.frame(x = 0:7) %>%
  mutate(
    l1 = x %/% 4,
    l2 = x %/% 2 %% 2,
    l3 = x %% 2
  ) %>%
  gather(level, value, -x) %>%
  mutate(
    level = gsub("l", "", level) %>%
      as.integer(),
    value = factor(value)
  ) %>%
  ggplot(aes(y = level, colour = value)) + 
  geom_segment(aes(x = x, xend = x + 1, yend = level)) + 
  geom_point(aes(x = x + 0.5)) +
  scale_colour_discrete(guide = "none") +
  scale_x_continuous(expand = c(0, 0)) + 
  scale_y_continuous(breaks = 1:3) +
  theme(
    axis.title.x = element_blank(),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank()
  )
```

## Number of elements in each dimension

Our algorithm demands that each dimension consist of $2^n$ elementen. This is in a real life dataset seldom the case. To relief the users from this problem, we created the `nd_grts()` function which handles several relevant classes: `list`, `data.frame`, `SpatialPoints`, `SpatialPointsDataFrame`, `SpatialPolygons` and `SpatialPolygonsDataFrame`. We will describe the main principle based on the `list` because the other classes can be seen as a special case.

When a `list` is supplied to `nd_grts()`, each element of the list represents one dimension. The elements should be a vector with unique values. Every vector $x$ will be expanded by `nd_grts()` into a vector $y$ of length $2^n$ with equal $n$ for all vectors of the list. The values of $y$ are interpreted as the midpoints of equal sized intervals. The smallest $n$ in choosen so that each interval defined by $y$ contains no more than one element from $x$. Let's illustrate this with the example below.

```{r}
x <- c(0.5, 1, 5)
n <- ceiling(log2(length(x))) # minimal n
2 ^ n
# calculate y
(y <- seq(min(x), max(x), length = 2 ^ n))
# calculate intervals 
delta <- diff(y)[1] / 2
cbind(y - delta, y + delta)
# note that the first interval contains two elements of x
# hence we must increase n
n <- n + 1
2 ^ n
# calculate y
(y <- seq(min(x), max(x), length = 2 ^ n))
# calculate intervals 
delta <- diff(y)[1] / 2
cbind(y - delta, y + delta)
# each interval contains only one element of x
```

```{r error = TRUE}
library(GRTS)
# nd_grts() uses a default 2 ^ n which can be too small
nd_grts(list(x = x))
# set a larger length using the new.length argument
nd_grts(list(x = x), new.length = 2 ^ n)
```

## Fixed scaling

In some cases we want a fixed scaling between some of the variables. An obvious example is a spatial layout were it makes more sense to keep a fixed scaling between both coordinates so that the distance between the points remains Euclidean. Therefore we added two more arguments to `nd_grts()`: `reference` and `scale`. `reference` must be a single character with the name of the dimension which is used as reference. `scale` is a named numeric vector defining the scale. Scale is somewhat analogue to the scale on maps: one unit of the reference equals $s$ units of the scaled variable. E.g. `reference = "A"` and `scale = c(B = 2, C = 1)` implies that 1 unit of "A" is as large as 2 units of "B" and as 1 unit of "C". 

The scaling works slightly different with `Spatial` objects. The first coordinate of is always used as the reference. The `Spatial` object is internally converted into a grid. The size of the grid cells is defined by the `cellsize` argument. The scale of the second coordinate is fixed to the ratio of the cellsizes. The user still can provide a `scale` argument in case of a `SpatialXXXDataFrame`. This is used to set a scale on the variables in the data.frame.

## Usage examples

### `data.frame`

We use the `meuse` data set in this example. We select the x, y and elev variables and round them. This reduces the required number of levels and speeds up the computation.

```{r fig.cap = "Rounded version of the meuse data set"}
library(sp)
data("meuse")
meuse %>%
  transmute(x = x %/% 200, y = y %/% 200, elev = round(elev, 0)) %>%
  distinct() -> meuse.dat
ggplot(meuse.dat, aes(x = x, y = y, colour = elev)) +
  geom_point() +
  coord_fixed()
```

The output of `nd_grts()` on a `data.frame` is a `list` with two elements: `object` and `design`. If all the variables are numeric, then `design` is the full grid on which the randomised 1D addresses are calculated. It contains the variables from the input augmented with two variables: `original_ranking` and `ranking`. `original_ranking` is output of `nd_ranking()` whereas `ranking` is the rank of `original_ranking`. `ranking` is identical to `original_ranking` when looking at the full grid. The `object` element from the list contains the subset of `design` which matches with the input data.frame. Note that the closest matches are returned, not the exact matches. While `original_rank` remains unchanged, `rank` is recalcuated.

```{r}
grts <- nd_grts(meuse.dat)
str(grts, 1)
glimpse(grts$design)
glimpse(grts$object)
```

```{r fig.cap = "Sample of 20 elements"}
grts$object %>%
  filter(ranking < 20) %>%
  ggplot(aes(x = x, y = y, colour = elev)) +
  geom_point() +
  coord_fixed()
```

`nd_grts()` can also handle integers, factors and characters. Characters are internally converted to factors, factors to integers and integers to numerics. The GRTS ranking is then calculated on the numeric values. Variables that were converted into numerics are backtransformed into their original class. The numeric values which are the nearest to the integer values are retained, the other values are discared. Hence, the `design` element from the output no longer contains all combinations used in `nd_ranking()` but only the relevant ones. `original_ranking` still is the values returned by `nd_ranking()`, `ranking` is it rank.

```{r fig.cap = "Example data.frame with a factor"}
meuse %>%
  transmute(x = as.integer(x %/% 200), y = as.integer(y %/% 200), ffreq) %>%
  distinct() -> meuse.dat
ggplot(meuse.dat, aes(x = x, y = y, colour = ffreq)) +
  geom_point() +
  coord_fixed()
grts <- nd_grts(meuse.dat)
glimpse(grts$design)
grts$design %>%
  summarise(
    n_x = n_distinct(x),
    n_y = n_distinct(y),
    n_ffreq = n_distinct(ffreq)
  )
glimpse(grts$object)
```

```{r fig.cap = "Sample of 20 elements"}
grts$object %>%
  filter(ranking < 20) %>%
  ggplot(aes(x = x, y = y, colour = ffreq)) +
  geom_point() +
  coord_fixed()
```

## `SpatialPoints`

Here we will work with the original meuse dataset using only the x and y coordinates. The `design` element of the `nd_grts()` output now contains a `SpatialGridDataFrame` with the GRTS ranking. The `object` element contains the centroids from the `design` grid cells which contain at least one point from the input.

```{r echo = FALSE, fig.cap = "Full meuse data set"}
ggplot(meuse, aes(x = x, y = y, colour = elev)) + 
  geom_point() + 
  coord_fixed()
```

```{r fig.cap = "Full grid with the GRTS ranking"}
meuse %>%
  select(x, y) %>%
  SpatialPoints() -> meuse.dat
grts <- nd_grts(meuse.dat, cellsize = c(200, 200))
str(grts, 1)
spplot(grts$design, zcol = "ranking")
grts$object %>%
  subset(ranking < 10)
```

## `SpatialPointsDataFrame`

```{r}
meuse %>%
  select(x, y) %>%
  SpatialPointsDataFrame(
    data = meuse %>%
      transmute(elev = round(elev, 0))
  ) -> meuse.dat
grts <- nd_grts(meuse.dat, cellsize = c(200, 200))
str(grts, 1)
grts$object %>%
  subset(ranking < 10)
```

## `SpatialPolygons`

For this example we use the `meuse.area` data set which is the outline of the `meuse` data set. The `design` element of `nd_grts()` contains the full `SpatialGridDataFrame`. Here we demonstrate the effect of a different scaling between both coordinates by setting a different cell size for both dimensions. The much larger cell size for the second dimension requires the full grid to extent far outside the bounding box along the second coordinate. The `object` element contains a `SpatialPixelsDataFrame` with the pixels who's centroid is contained within the polygons. Here the effect of the unequal cell sizes is clearly seen.

```{r}
data("meuse.area")
meuse.sr <- SpatialPolygons(
  list(Polygons(list(Polygon(meuse.area)), "meuse.area"))
)
ggplot(meuse.sr, aes(x = long, y = lat)) +
  geom_path() +
  coord_fixed()
```

```{r}
grts <- nd_grts(meuse.sr, cellsize = c(100, 400))
str(grts, 1)
```

```{r echo = FALSE, fig.cap = "Full grid with GRTS ranking"}
ggplot(as.data.frame(grts$design), aes(x = x, y = y)) +
  geom_tile(aes(fill = ranking)) +
  geom_path(data = meuse.sr, aes(x = long, y = lat)) +
  scale_fill_gradientn(colours = terrain.colors(20)) +
  coord_fixed() +
  theme(
    axis.title = element_blank(),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  )
```

```{r echo = FALSE, fig.cap = "Pixels which have their centroid within the input shape with GRTS ranking"}
ggplot(as.data.frame(grts$object), aes(x = x, y = y)) +
  geom_tile(aes(fill = ranking)) +
  geom_path(data = meuse.sr, aes(x = long, y = lat)) +
  scale_fill_gradientn(colours = terrain.colors(20)) +
  coord_fixed() +
  theme(
    axis.title = element_blank(),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  )
```

## `SpatialPolygonsDataFrame`

```{r, fig.cap = "Example data for `SpatialPolygonsDataFrame`"}
meuse %>%
  mutate(
    x = x + rnorm(n(), sd = 50),
    y = y + rnorm(n(), sd = 50)
  ) %>%
  `coordinates<-`(c("x", "y")) -> meuse.dat
coordinates(meuse) <- c("x", "y")
library(rgeos)
triang <- gDelaunayTriangulation(meuse)
SpatialPolygonsDataFrame(
  triang,
  over(triang, meuse)
) %>%
  gUnaryUnion(.@data$ffreq) %>%
  SpatialPolygonsDataFrame(
    meuse@data %>%
      distinct(ffreq)
  ) -> meuse.dat
spplot(meuse.dat, zcol = "ffreq")
```

```{r fig.cap = "Sample of 20 elements"}
grts <- nd_grts(meuse.dat, cellsize = c(200, 200))
str(grts, 1)
grts$object %>%
  subset(ranking < 20) %>%
  as.data.frame() %>%
  ggplot(aes(x = x, y = y, colour = ffreq)) +
  geom_point() +
  coord_equal()
```

